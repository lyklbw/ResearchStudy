## CLASS的基本框架

##### 基本概念：

包含创建类，实例化，

给实例内部的变量赋值，

定义类之中方法，调用方法 Class::class来定义函数（方法）

属性即变量 方法即函数

如果您没有使用任何访问修饰符定义变量，类的成员将被假定为私有成员：

**私有化的好处**：

可以自行调控属性的读写权限，也更方便检查数据有效性

##### 构造函数

类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

（对象的初始化以及清理）

构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。

```c++
//firstly u just define a complete Class,for a instance Line
//构造函数
Line::Line(double a,double b):length(len)
{
 //many things that you can do, but not defining a function
}
```

在类对象的赋值过程中，只会对类中的数据成员进行赋值，而不对成员函数赋值。

例如：obj1 和 obj2 是类 ClassA 的两个对象，那么对象赋值语句“obj2 = obj1;” 会把对象 obj1 的数据成员的值逐位赋给对象 obj2。

##### 拷贝构造函数

它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。

构造函数的方法：

有参无参

普通构造，拷贝构造

浅拷贝可能带来堆区内存重复释放

***析构：***

将堆区开辟的数据释放

编译器默认会为我们提供几种函数

无参<参数构造<拷贝构造函数

```
Line::Line(const Line &obj)//不需要指出函数返回数据类型
{
    cout << "调用拷贝构造函数并为指针 ptr 分配内存" << endl;
    ptr = new int;
    *ptr = *obj.ptr; // 拷贝值，取obj里面的ptr的地址
}
//析构函数  分配内存记得释放——这是好习惯
Line::~Line(void)
{
    cout << "释放内存" << endl;
    delete ptr;
}
```

##### 友元

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

友元函数：

不是任何类的成员函数，但是若class内声明了友元函数，则其可以访问各个类的各个属性

##### 内联函数

引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的节省。

**类结构中所在的类说明内部定义的函数是内联函数**。

##### this指针

跟struct的this的用法基本一致，这里要注意的是，用this调用class内部的参数时，如果不同范围跟权限的属性重名，可能会出现优先级的问题（这里没有实践），但是这也告诉我们，不同权限的变量不要重名。

##### 静态成员

静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零(**当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。**)。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 **::** 来重新声明静态变量从而对它进行初始化

```C++
class Box{
	public:
		static int objectCount;//初始为零
		...
}
int Box::objectCount=0;
```

##### 静态成员函数

如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，**静态函数**只要使用类名加范围解析运算符 **::** 就可以访问

静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数

其不能使用this指针

##### 继承

继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**。 

for an instance

```c++
class Shape
{public:
    ....
};
class Rectangle: public shape
{public:
...
}
```

| 访问主体   | protected | private | public |
| ---------- | --------- | ------- | ------ |
| 同一个类内 | yes       | yes     | yes    |
| 派生类     | yes       | no      | yes    |
| 外部       | no        | no      | yes    |

可以多继承，用逗号分隔开

#### 运算符重载

##### 重载运算符

你可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

模板

##### 重载函数

在同一个作用域内(比如说一个类的内部），可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同.不能仅通过返回类型的不同来重载函数。

```c++
 public:
      void print(int i) {
        cout << "整数为: " << i << endl;
      }
 
      void print(double  f) {
        cout << "浮点数为: " << f << endl;
      }
```

##### 多态

**多态**按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。

假设Shape基类存在一个area()函数，此时其两个派生类的内部也定义了area()函数（标题为：基类指针可以用来指向派生类）

```
//正常按照已学知识来写：
Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);
   shape = &rec;//基类指针可以用来指向派生类
   shape->area();
   shape = &tri;
   shape->area();
```

这个时候编译器会调用的area()会是基类的函数而不是派生类的，导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的**静态多态**，或**静态链接** - 函数调用在程序执行前就准备好了。有时候这也被称为**早绑定**，因为 area() 函数在程序编译期间就已经设置好了。

在 Shape 类中，area() 的声明前放置关键字 **virtual**。可以解决这个问题，基类的area()会变成**虚函数**

***虚函数：***

**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

##### 数据抽象：

